<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ANIMA</title>
    <!-- Add React and other dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Montserrat:ital,wght@0,100..900;1,100..900&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
        rel="stylesheet">
    <link href="styles.css" rel="stylesheet">
</head>

<body>
    <div class="container">
        <header>
            <h1>ANIMA Project</h1>
            <p>A Computer Application to Explore 53-Tone Equal Temperament Harmonies Through Modal Interchange</p>
        </header>

        <section class="project-section">
            <h2 class="text-2xl font-bold mb-4">Project Overview</h2>
            <p>The Microtonal Explorer is a novel computer application that enables real-time exploration and
                manipulation of microtonal harmonies in 53-tone equal temperament (53-TET). Building upon traditional
                12-TET modes and incorporating principles from 31-TET, that extend minor/major interval qualities with
                subminor, neutral, and supermajor distinctions. Subsequently, extending to 53-TET’s harmonic landscape with detailed interval
                qualities. The application offers an intuitive interface with real-time visualization and MIDI Polyphonic Expression (MPE) support. 
                Through a custom MaxForLive application called the Bridge, it connects conventional MIDI protocols with 53-TET chord construction,
                ensuring compatibility with modern digital audio workstations like Ableton Live (11/12). The system
                features interactive chord manipulation tools, a comprehensive Scale Editor, and implements modal
                interchange techniques, allowing musicians to discover new harmonic possibilities while maintaining
                meaningful connections to established modal frameworks.</p>
        </section>

        <!-- Key Features -->
        <section class="project-section">
            <h2 class="text-2xl font-bold mb-4">Key Features</h2>
            <div class="features-grid">
                <div class="feature-card">
                    <h3>Scale Editor</h3>
                    <p>Interactive visualization tool for editing interval distances and exploring different configurations in
                        53-TET, with comprehensive control over interval qualities from subminor to supermajor.</p>
                </div>
                <div class="feature-card">
                    <h3>Modal Interchange</h3>
                    <p>The computer application uses an 8x8 grid interface for exploring parallel and relative modal substitutions, allowing real-time
                        experimentation with chord progressions and harmonic trajectories in microtonality.</p>
                </div>
                <div class="feature-card">
                    <h3>Voicing Editor</h3>
                    <p>Spiral visualization interface for chord voicing control, featuring dynamic voice leading and intuitive
                        representation of note relationships across octaves based on Chew's method.</p>
                </div>
                <div class="feature-card">
                    <h3>MIDI Integration</h3>
                    <p>Custom MaxForLive Bridge application enabling precise microtonal control through MPE, maintaining
                        compatibility with Ableton Live</p>
                </div>
                <div class="feature-card">
                    <h3>Microtonal Chord Naming System</h3>
                    <p>Explore the comprehensive chord naming convention used in 53-TET to represent the nuanced interval qualities
                        beyond traditional Western harmony.</p>
                    <div class="text-center">
                        <a href="chord-naming.html" class="resource-button">View Chord Naming Guide</a>
                    </div>
                </div>
            </div>
        </section>

        <!-- Add the chord progression section here -->
        <section class="project-section">
            <div id="chord-progression-root"></div>
        </section>

        <!-- Download the app     -->
        <section class="project-section">
            <h2 class="text-2xl font-bold mb-4">Download & Installation</h2>
            <p>Microtonal Explorer is currently available for macOS users.</p>

            <div class="feature-card">
                <h3 class="text-blue-500 mb-2">Download</h3>
                <!-- <p><a href="https://github.com/fifty-three-tet/anima/releases/download/v1.0.0/ChromaFlow_Interface_v1.0.0.zip" -->
                        <p><a href=""
                        class="download-button">Download Microtonal Explorer v1.0.0</a></p>
                <p class="version-info">Version 1.0.0 - macOS only</p>
            </div>

            <div class="feature-card">
                <h3>Installation Instructions for Mac</h3>
                <ol>
                    <li>Download the application file</li>
                    <li>Unzip the file if it's compressed</li>
                    <li><strong>Important:</strong> When you see the message "ChromaFlow_Interface_v1.0.0 is damaged and
                        can't be opened":
                        <ul>
                            <li>Open Terminal (find it in Applications > Utilities)</li>
                            <li>Copy and paste this command (replace PATH_TO_APP with the path to where your app is located):</li>
                            <li><code>xattr -cr ~/PATH_TO_APP/ChromaFlow_Interface_v1.0.0.app</code></li>
                        </ul>
                    </li>
                    <li>After running the Terminal command:
                        <ul>
                            <li>Right-click (or Control-click) on the app icon</li>
                            <li>Select "Open" from the context menu</li>
                            <li>Click "Open" in the security dialog</li>
                        </ul>
                    </li>
                </ol>
                <div class="feature-card">
                    <h3>Note</h3>
                    <p>These steps are necessary because the app isn't signed with an Apple Developer certificate. This
                        is a one-time process to tell macOS that you trust this application.</p>
                </div>
                <li>If prompted, allow any required permissions for:
                    <ul>
                        <li>MIDI access</li>
                        <li>Audio access</li>
                    </ul>
                </li>
                </ol>
            </div>
        </section>

        <section class="project-section">
            <h2 class="text-2xl font-bold mb-4">Documentation</h2>
            <p>The paper is available in this link</p>
            <ul>
                <li>If you use this work in your research, please cite it as follows:</li>
            </ul>
        </section>

        <section class="project-section">
            <h2 class="text-2xl font-bold mb-4">License</h2>
            <p>This project is licensed under the GNU General Public License v3.0 - see the LICENSE file in the
                repository for details.</p>
        </section>
    </div>
    <!-- Add the React component script -->
    <script type="text/babel">
    // Add Modal Interchange Info Component
    // Updated Modal Interchange Info Component
        const ModalInterchangeInfo = () => {
            return (
                <div className="mb-8 p-6 bg-gray-50 rounded-lg">
                    <h2 className="text-2xl font-bold mb-4 text-blue-600">Understanding Modal Interchange</h2>

                    <div className="flex flex-col md:flex-row gap-6 mb-4">
                        <div className="md:w-3/5">
                            <p className="mb-4">
                                Although harmonic exploration can be made through singular modes,
                                a compelling method for expanding research to other chords is through modal interchanges.
                                Modal interchange involves borrowing chords from parallel or relative modes
                                to introduce new harmonic colors while maintaining a connection to the original mode.
                            </p>

                            <div className="flex flex-col gap-4 mb-4">
                                <div className="p-3 bg-white rounded-lg shadow-sm" style={{ borderRadius: "10px" }}>
                                    <h3 className="font-bold text-blue-500 mb-2">Parallel Interchange</h3>
                                    <p>This involves borrowing chords from a mode sharing the same root as the original one.
                                        For instance, if we are in C major/Ionian, we can borrow from C Aeolian.</p>
                                </div>

                                <div className="p-3 bg-white rounded-lg shadow-sm" style={{ borderRadius: "10px" }}>
                                    <h3 className="font-bold text-blue-500 mb-2">Relative Interchange</h3>
                                    <p>This involves shifting to a mode where the original root
                                        functions as a different degree of the scale and borrowing chords from the obtained mode.
                                        For instance, starting from C major/Ionian, an Aeolian relative modal interchange
                                        would place C at the 6th degree of E♭ major/Ionian.
                                        Therefore, we can borrow from E♭ major.</p>
                                </div>
                            </div>

                            <div className="p-3 bg-white rounded-lg shadow-sm" style={{ borderRadius: "10px" }}>
                                <p>
                                    The distinction between parallel and relative modal interchanges appears more clearly
                                    when applied to chord progressions. The figure shows a simple "I vi ii V I" 12-TET progression in C major,
                                    and the parallel and relative Aeolian interchanges for the middle chords.
                                </p>

                                <p className="mt-2">
                                    The move from Ionian to Aeolian means adding a ♭3 (E♭), ♭6 (A♭), and ♭7 (B♭).
                                    In the parallel interchange, the chords are still based on the root of C.
                                    Am7 becomes A♭maj7 to correspond to the new bag of notes of C Aeolian. Similarly, we obtain Dm7♭5 and Gm7.
                                </p>

                                <p className="mt-2">
                                    In the relative interchange, the chords are now based on the root of E♭.
                                    The vi is, therefore, the 6th degree of E♭ major, i.e., Cm7. Similarly, we obtain Fm7 and B♭7.
                                </p>
                            </div>
                        </div>

                        <div className="md:w-2/5">
                            <div className="bg-white p-3 rounded-lg shadow-sm" style={{ borderRadius: "10px" }}>
                                <img src="figures/modal_interchanges.png" alt="Modal Interchange Diagram" className="w-full rounded-lg" />
                                <p className="text-sm text-gray-600 mt-2 italic">Figure: Modal interchange examples showing parallel and relative Aeolian interchanges on a C major progression.</p>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Chord Progression Grid Component

        const ChordProgressionGrid = () => {
            const [activeButtons, setActiveButtons] = React.useState(new Set());
            const [audioCache, setAudioCache] = React.useState(new Map());
            const [loadingStatus, setLoadingStatus] = React.useState(new Map());
            const [debugInfo, setDebugInfo] = React.useState(null);
            const audioContext = React.useRef(null);
            const activeSources = React.useRef(new Map());

            // Notes for each progression set
            const progressionNotes = [
                "This progression uses the distribution of note distances [0, 9, 9, 4, 9, 9, 9, 4] which corresponds to the standard tuning of 12-TET, [Cmaj7, Dm7, Em7, Fmaj7, G7, Am7, Bø7, Cmaj7]. The progression used is I, vi, IV, ii, I",
                "The second example is composed of the note distances [0, 9, 8, 5, 9, 8, 4, 10], which produces the chords [CvMvm7, Dm7, vEø^m7, FvMvM7, Gvm7, vA^m^m7, vBb^Mmaj7, CvMvm7]. The progression used is I, IV, II, V, I (the major or minor notations are not encoded as intermediate colors are included)",
                "The third example is composed of the note distances [0, 9, 8, 5, 9, 8, 9, 5], which produces the chords [CvMvM7, Dm7, vE^m^m7, FvMvM7, GvMm7, vA^m^m7, vBbø7, CvMvM7]. The progression used is I, I/3rd, IV, II, I"
            ];

            const progressions = [
                // First set of progressions (Ionian-based)
                { chords: ['Cmaj7[I]', 'Am7[VI]', 'Fmaj7[IV]', 'Dm7[II]', 'Cmaj9[I]'], label: 'Original' },
                { chords: ['Cmaj7[I]', 'Aø7[VI]', 'F7[IV]', 'Dm7[II]', 'Cmaj9[I]'], label: 'P: Dorian' },
                { chords: ['Cmaj7[I]', 'vG#maj7[VI]', 'Fm7[IV]', 'vC#maj7[II]', 'Cmaj9[I]'], label: 'P: Phrygian' },
                { chords: ['Cmaj7[I]', 'vG#maj7[VI]', 'Fm7[IV]', 'Dø7[II]', 'Cmaj9[I]'], label: 'P: Aeolian' },
                { chords: ['Cmaj7[I]', 'Gm7[V]', 'vD#maj7[III]', 'Cm7[I]', 'Cmaj9[I]'], label: 'R: Dorian' },
                { chords: ['Cmaj7[I]', 'Fm7[IV]', 'vC#maj7[II]', 'Bbm7[VII]', 'Cmaj9[I]'], label: 'R: Phrygian' },
                { chords: ['Cmaj7[I]', 'Cm7[I]', 'vG#maj7[VI]', 'Fm7[IV]', 'Cmaj9[I]'], label: 'R: Aeolian' },
                { chords: ['Cmaj7[I]', 'Bbm7[VII]', 'vF#maj7[V]', 'vD#m7[III]', 'Cmaj9[I]'], label: 'R: Locrian' },

                // Divider
                { chords: ['', '', '', '', ''], label: '' },

                // Second set of progressions (original from code)
                { chords: ['CvMvm7[I]', 'FvMvM7[IV]', 'Dm7[II]', 'Gvm7[V]', 'CvMvm9[I]'], label: 'Original' },
                { chords: ['CvMvm7[I]', 'Fvm7[IV]', 'vDø^m7[II]', 'vG^m^m7[V]', 'CvMvm9[I]'], label: 'P: Dorian' },
                { chords: ['CvMvm7[I]', 'F^m^m7[IV]', 'C#vMvM7[II]', 'vF#^Mmaj7[V]', 'CvMvm9[I]'], label: 'P: Phrygian' },
                { chords: ['CvMvm7[I]', '^Fm7[IV]', 'vC#Mmaj7[II]', 'Gø^m7[V]', 'CvMvm9[I]'], label: 'P: Aeolian' },
                { chords: ['CvMvm7[I]', 'vD#vMvM7[III]', 'Cm7[I]', 'Fvm7[IV]', 'CvMvm9[I]'], label: 'R: Dorian' },
                { chords: ['CvMvm7[I]', 'C#vMvM7[II]', '^Bbm7[VII]', 'D#vm7[III]', 'CvMvm9[I]'], label: 'R: Phrygian' },
                { chords: ['CvMvm7[I]', 'G#vMvM7[VI]', '^Fm7[IV]', '^Bbvm7[VII]', 'CvMvm9[I]'], label: 'R: Aeolian' },
                { chords: ['CvMvm7[I]', '^GvMvM7[V]', '^Em7[III]', '^Avm7[VI]', 'CvMvm9[I]'], label: 'R: Locrian' },

                // Divider
                { chords: ['', '', '', '', ''], label: '' },

                // NEW Third set of progressions
                { chords: ['CvMvM7[I]', 'CvMvM7/vE[I]', 'FvMvM7[IV]', 'Dm7[II]', 'CvMvM7[I]'], label: 'Original' },
                { chords: ['CvMvM7[I]', 'Cm7/vD#[I]', 'FvMm7[IV]', 'vD^m^m7[II]', 'CvMvM9[I]'], label: 'P: Dorian' },
                { chords: ['CvMvM7[I]', 'C^m^m7/D#[I]', 'F^m^m7[IV]', 'C#vMvM7[II]', 'CvMvM9[I]'], label: 'P: Phrygian' },
                { chords: ['CvMvM7[I]', 'C^m^m7/D#[I]', '^Fm7[IV]', 'Dø7[II]', 'CvMvM9[I]'], label: 'P: Aeolian' },
                { chords: ['CvMvM7[I]', 'BbvMvM7/vD[VII]', 'vD#vMvM7[III]', 'Cm7[I]', 'CvMvM9[I]'], label: 'R: Dorian' },
                { chords: ['CvMvM7[I]', 'G#vMvM7/C[VI]', 'C#vMvM7[II]', '^Bbm7[VII]', 'CvMvM9[I]'], label: 'R: Phrygian' },
                { chords: ['CvMvM7[I]', 'D#vMvM7/G[III]', 'G#vMvM7[VI]', '^Fm7[IV]', 'CvMvM9[I]'], label: 'R: Aeolian' },
                { chords: ['CvMvM7[I]', 'C#vMvM7/F[II]', 'F#vMvM7[V]', 'D#m7[III]', 'CvMvM9[I]'], label: 'R: Locrian' }
            ];

            // Special mapping for chord names to their correct filenames
            const chordToFileMapping = {
                "vvG#^Mm7[VI]": "vvG#^Mm7[VI].wav",
                "^Bbm7[VII]": "new^Bbm7[VII].wav",
                "^Fm7[IV]": "new^Fm7[IV].wav",
                "BbvMvM7/vD[VII]": "newBbvMvM7_vD[VII].wav",
                "C#vMvM7/F[II]": "newC#vMvM7_F[II].wav",
                "C#vMvM7[II]": "newC#vMvM7[II].wav",
                "C^m^m7/D#[I]": "newC^m^m7_D#[I].wav",
                "Cm7/vD#[I]": "newCm7_vD#[I].wav",
                "Cm7[I]": "newCm7[I].wav",
                "CvMvM7/vE[I]": "newCvMvM7_vE[I].wav",
                "CvMvM7[I]": "newCvMvM7[I].wav",
                "CvMvM9[I]": "newCvMvM9[I].wav",
                "D#m7[III]": "newD#m7[III].wav",
                "D#vMvM7/G[III]": "newD#vMvM7_G[III].wav",
                "Dm7[II]": "newDm7[II].wav",
                "F#vMvM7[V]": "newF#vMvM7[V].wav",
                "F^m^m7[IV]": "newF^m^m7[IV].wav",
                "FvMm7[IV]": "newFvMm7[IV].wav",
                "FvMvM7[IV]": "newFvMvM7[IV].wav",
                "G#vMvM7/C[VI]": "newG#vMvM7_C[VI].wav",
                "G#vMvM7[VI]": "newG#vMvM7[VI].wav",
                "vD#vMvM7[III]": "newvD#vMvM7[III].wav",
                "vD^m^m7[II]": "newvD^m^m7[II].wav",
                "^Avm7[VI]": "^Avm7[VI].wav",
                "^Bbm7[VII]": "^Bbm7[VII].wav",
                "^Bbvm7[VII]": "^Bbvm7[VII].wav",
                "^Em7[III]": "^Em7[III].wav",
                "^Fm7[IV]": "^Fm7[IV].wav",
                "^GvMvM7[V]": "^GvMvM7[V].wav",
                "Am7[VI]": "Am7[VI].wav",
                "Aø7[VI]": "Aø7[VI].wav",
                "Bb^M^M7/^D[VII]": "Bb^M^M7_^D[VII].wav",
                "Bb^Mm7[VII]": "Bb^Mm7[VII].wav",
                "Bbm7[VII]": "Bbm7[VII].wav",
                "C^M^M7/^E[I]": "C^M^M7_^E[I].wav",
                "C^M^M7[I]": "C^M^M7[I].wav",
                "C^M^M9[I]": "C^M^M9[I].wav",
                "Cmaj7[I]": "Cmaj7[I].wav",
                "Cmaj9[I]": "Cmaj9[I].wav",
                "Cvmvm7/vvD#[I]": "Cvmvm7_vvD#[I].wav",
                "CvMvm7[I]": "CvMvm7[I].wav",
                "CvMvm9[I]": "CvMvm9[I].wav",
                "D#vm7[III]": "D#vm7[III].wav",
                // "Dm7[II]" also appears above; if needed, ensure consistency:
                "Dm7[II]": "Dm7[II].wav",
                "Dø7[II]": "Dø7[II].wav",
                "F^Mm7[IV]": "F^Mm7[IV].wav",
                "F7[IV]": "F7[IV].wav",
                "FM^M7[IV]": "FM^M7[IV].wav",
                "Fm7[IV]": "Fm7[IV].wav",
                "Fmaj7[IV]": "Fmaj7[IV].wav",
                "Fvm7[IV]": "Fvm7[IV].wav",
                "Gmaj7[IV]": "Gmaj7[IV].wav",
                "Gø^m7[V]": "Gø^m7[V].wav",
                "Gvm7[V]": "Gvm7[V].wav",
                "Gvmvm7[V]": "Gvmvm7[V].wav",
                "upGvmvm7[V]": "upGvmvm7[V].wav",
                "vC#maj7[II]": "vC#maj7[II].wav",
                "vC#Mmaj7[II]": "vC#Mmaj7[II].wav",
                "vD#^M^M7/^G[III]": "vD#^M^M7_^G[III].wav",
                "vD#M^M7[III]": "vD#M^M7[III].wav",
                "vD#m7[III]": "vD#m7[III].wav",
                "vD#maj7[III]": "vD#maj7[III].wav",
                "vD#vMvM7[III]": "vD#vMvM7[III].wav",
                "vDø^m7[II]": "vDø^m7[II].wav",
                "vDvMvM7[III]": "vDvMvM7[III].wav",
                "vF#^Mmaj7[V]": "vF#^Mmaj7[V].wav",
                "vF#maj7[V]": "vF#maj7[V].wav",
                "vF^m^m7[IV]": "vF^m^m7[IV].wav",
                "vFm7[IV]": "vFm7[IV].wav",
                "vG#M^M7[VI]": "vG#M^M7[VI].wav",
                "vG#maj7[VI]": "vG#maj7[VI].wav",
                "vG^m^m7[V]": "vG^m^m7[V].wav",
                "vvC#^M^M7/F[II]": "vvC#^M^M7_F[II].wav",
                "vvC#M^M7[II]": "vvC#M^M7[II].wav",
                "vvD#^Mm7[III]": "vvD#^Mm7[III].wav",
                "vvF#M^M7[V]": "vvF#M^M7[V].wav",
                "vvG#^M^M7/C[VI]": "vvG#^M^M7_C[VI].wav"
            };

            // Function to get the correct filename for a chord
            const getFileName = (chord, isThirdGroup = false) => {
                if (!chord) return '';

                // If this chord has a known mapping, use it.
                if (chordToFileMapping.hasOwnProperty(chord)) {
                    return chordToFileMapping[chord];
                }

                // Otherwise, start with the original chord name.
                let fileName = chord;

                // Replace any slashes with underscores.
                fileName = fileName.replace(/\//g, '_');

                return fileName + '.wav';
            };

            // Initialize audio context
            React.useEffect(() => {
                // Create AudioContext on component mount
                if (!audioContext.current) {
                    // Use newer AudioContext standard with fallback
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    audioContext.current = new AudioContextClass();
                }

                return () => {
                    // Cleanup on component unmount
                    if (audioContext.current && audioContext.current.state !== 'closed') {
                        // Stop all playing sounds
                        activeSources.current.forEach(source => {
                            if (source) {
                                try {
                                    source.stop();
                                } catch (e) {
                                    // Ignore errors if source already stopped
                                }
                            }
                        });

                        // Close audio context
                        audioContext.current.close();
                    }
                };
            }, []);

            // Enhanced audio loading function using Web Audio API
            const loadAudio = async (chord, isThirdGroup = false) => {
                if (chord === '' || audioCache.has(chord)) return;

                setLoadingStatus(prev => new Map(prev).set(chord, 'loading'));

                try {
                    const fileName = getFileName(chord, isThirdGroup);
                    const baseUrl = 'https://fifty-three-tet.github.io/anima/audio/';

                    // Try a different URL encoding approach
                    // First encode each special character individually
                    let encodedFileName = fileName
                        .replace(/\[/g, '%5B')
                        .replace(/\]/g, '%5D')
                        .replace(/\^/g, '%5E')
                        .replace(/#/g, '%23');

                    const finalUrl = baseUrl + encodedFileName;

                    console.log(`Trying to load: ${chord} → ${fileName} (URL: ${finalUrl})`);

                    // Fetch the audio file
                    const response = await fetch(finalUrl);
                    if (!response.ok) {
                        console.error(`File not found: ${fileName} (Status: ${response.status})`);
                        setLoadingStatus(prev => new Map(prev).set(chord, false));
                        return;
                    }

                    // Get the audio data as an ArrayBuffer
                    const arrayBuffer = await response.arrayBuffer();

                    // Decode the audio data
                    const audioBuffer = await audioContext.current.decodeAudioData(arrayBuffer);

                    // Store the decoded buffer in our cache
                    setAudioCache(prev => {
                        const newCache = new Map(prev);
                        newCache.set(chord, audioBuffer);
                        return newCache;
                    });

                    setLoadingStatus(prev => new Map(prev).set(chord, true));
                    setDebugInfo(null);

                } catch (error) {
                    console.error(`Failed to load audio for chord: ${chord}`, error);
                    setLoadingStatus(prev => new Map(prev).set(chord, false));
                }
            };

            // Function to play a chord using Web Audio API
            const playChord = (chord, buttonId) => {
                // Get the audio buffer from cache
                const buffer = audioCache.get(chord);
                if (!buffer) {
                    setDebugInfo(`No buffer available for ${chord}`);
                    return null;
                }

                // Resume the audio context if it's suspended (needed for autoplay policies)
                if (audioContext.current.state === 'suspended') {
                    audioContext.current.resume();
                }

                // Create a new buffer source
                const source = audioContext.current.createBufferSource();
                source.buffer = buffer;

                // Create a gain node for volume control
                const gainNode = audioContext.current.createGain();
                gainNode.gain.value = 1.0; // Set to 60% volume

                // Connect source to gain, then to destination (speakers)
                source.connect(gainNode);
                gainNode.connect(audioContext.current.destination);

                // Start playback
                source.start(0);

                // Store source so we can stop it later if needed
                activeSources.current.set(buttonId, source);

                // Set up ended event handler
                source.onended = () => {
                    setActiveButtons(prev => {
                        const next = new Set(prev);
                        next.delete(buttonId);
                        return next;
                    });
                    activeSources.current.delete(buttonId);
                };

                return source;
            };

            // Function to stop a playing chord
            const stopChord = (buttonId) => {
                const source = activeSources.current.get(buttonId);
                if (source) {
                    try {
                        source.stop();
                    } catch (e) {
                        // Ignore errors if source already stopped
                    }
                    activeSources.current.delete(buttonId);
                }
            };

            // Load all audio files when component mounts
            React.useEffect(() => {
                // Find divider indices to determine chord groups
                const dividerIndices = progressions.reduce((indices, row, index) => {
                    if (row.label === '') indices.push(index);
                    return indices;
                }, []);
                const groupStartIndices = [0, ...dividerIndices.map(idx => idx + 1)];

                // Build a Map: chord -> true if it appears in group three, false otherwise
                const chordGroupMap = new Map();
                progressions.forEach((row, rowIndex) => {
                    const isThirdGroup = groupStartIndices.length > 2 && rowIndex >= groupStartIndices[2];
                    row.chords.forEach(chord => {
                        if (chord !== '') {
                            chordGroupMap.set(chord, chordGroupMap.has(chord) ?
                                (chordGroupMap.get(chord) || isThirdGroup) : isThirdGroup);
                        }
                    });
                });

                // Preload each unique chord
                chordGroupMap.forEach((isThirdGroup, chord) => {
                    loadAudio(chord, isThirdGroup);
                });
            }, []);

            // Handle chord button click
            const handleChordClick = (chord, rowIndex, colIndex) => {
                if (chord === '') return;

                const buttonId = `${rowIndex}-${colIndex}`;

                // If button is already active, stop playback
                if (activeButtons.has(buttonId)) {
                    stopChord(buttonId);
                    setActiveButtons(prev => {
                        const next = new Set(prev);
                        next.delete(buttonId);
                        return next;
                    });
                    return;
                }

                // If audio isn't loaded yet, don't try to play
                if (loadingStatus.get(chord) !== true) {
                    setDebugInfo(`Unable to play: ${chord} (Status: ${loadingStatus.get(chord)})`);
                    return;
                }

                try {
                    // Play the chord
                    playChord(chord, buttonId);

                    // Mark button as active
                    setActiveButtons(prev => {
                        const next = new Set(prev);
                        next.add(buttonId);
                        return next;
                    });

                    // Failsafe: ensure button gets deactivated even if ended event doesn't fire
                    const buffer = audioCache.get(chord);
                    if (buffer) {
                        const duration = buffer.duration;
                        setTimeout(() => {
                            if (activeButtons.has(buttonId)) {
                                setActiveButtons(prev => {
                                    const next = new Set(prev);
                                    next.delete(buttonId);
                                    return next;
                                });
                                activeSources.current.delete(buttonId);
                            }
                        }, (duration * 1000) + 500);
                    }

                } catch (error) {
                    console.error("Error playing audio:", error);
                    setDebugInfo(`Error playing: ${chord} - ${error.message}`);

                    // Make sure button is deactivated on error
                    setActiveButtons(prev => {
                        const next = new Set(prev);
                        next.delete(buttonId);
                        return next;
                    });
                }
            };

            // Find the indices where we have dividers (blank rows)
            const dividerIndices = progressions.reduce((indices, row, index) => {
                if (row.label === '') indices.push(index);
                return indices;
            }, []);

            // This will give us the starting index for each group
            const groupStartIndices = [0, ...dividerIndices.map(idx => idx + 1)];

            // Render component
            return (
                <div className="p-6 bg-white rounded-lg shadow">
                    <h2 className="text-2xl font-bold mb-4">Modal Interchange Examples</h2>

                    {/* First progression group */}
                    <div className="mb-8">
                        <div className="bg-white p-3 rounded-lg shadow-sm mb-4">
                            <p className="text-sm">{progressionNotes[0]}</p>
                        </div>
                        <div className="flex flex-col md:flex-row chord-progressions gap-4">
                            <div className="flex-1">
                                <div className="grid gap-1">
                                    {progressions.slice(groupStartIndices[0], dividerIndices[0]).map((row, rowIndex) => (
                                        <div key={rowIndex} className="flex gap-1 items-center">
                                            {row.chords.map((chord, colIndex) => (
                                                <button
                                                    key={`${rowIndex}-${colIndex}`}
                                                    onClick={() => handleChordClick(chord, rowIndex, colIndex)}
                                                    className={`text-xs p-3 rounded-xl flex-1 text-center transition-colors border border-gray-300 chord-button
                                            ${chord === ''
                                                            ? 'border-none'
                                                            : activeButtons.has(`${rowIndex}-${colIndex}`)
                                                                ? 'text-white'
                                                                : loadingStatus.get(chord) === false
                                                                    ? 'bg-red-100 text-red-600'
                                                                    : 'bg-white hover:bg-gray-200'
                                                        }`}
                                                    style={{
                                                        backgroundColor: activeButtons.has(`${rowIndex}-${colIndex}`) ? 'var(--button-active)' : ''
                                                    }}
                                                    disabled={chord === '' || loadingStatus.get(chord) !== true}
                                                >
                                                    {chord}
                                                </button>
                                            ))}
                                            <div className="w-24 text-gray-600 font-medium text-xs">
                                                {row.label}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                            <div className="image-container">
                                <img src="figures/first_example.png" alt="Scale visualization" className="w-full rounded-lg shadow-sm" />
                            </div>
                        </div>
                    </div>

                    {/* Second progression group */}
                    <div className="mb-8">
                        <div className="bg-white p-3 rounded-lg shadow-sm mb-4">
                            <p className="text-sm">{progressionNotes[1]}</p>
                        </div>
                        <div className="flex flex-col md:flex-row chord-progressions gap-4">
                            <div className="flex-1">
                                <div className="grid gap-1">
                                    {progressions.slice(groupStartIndices[1], dividerIndices[1]).map((row, rowIndex) => {
                                        const adjustedRowIndex = rowIndex + groupStartIndices[1];
                                        return (
                                            <div key={adjustedRowIndex} className="flex gap-1 items-center">
                                                {row.chords.map((chord, colIndex) => (
                                                    <button
                                                        key={`${adjustedRowIndex}-${colIndex}`}
                                                        onClick={() => handleChordClick(chord, adjustedRowIndex, colIndex)}
                                                        className={`text-xs p-3 rounded-xl flex-1 text-center transition-colors border border-gray-300 chord-button
                                                ${chord === ''
                                                                ? 'border-none'
                                                                : activeButtons.has(`${adjustedRowIndex}-${colIndex}`)
                                                                    ? 'text-white'
                                                                    : loadingStatus.get(chord) === false
                                                                        ? 'bg-red-100 text-red-600'
                                                                        : 'bg-white hover:bg-gray-200'
                                                            }`}
                                                        style={{
                                                            backgroundColor: activeButtons.has(`${adjustedRowIndex}-${colIndex}`) ? 'var(--button-active)' : ''
                                                        }}
                                                        disabled={chord === '' || loadingStatus.get(chord) !== true}
                                                    >
                                                        {chord}
                                                    </button>
                                                ))}
                                                <div className="w-24 text-gray-600 font-medium text-xs">
                                                    {row.label}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                            <div className="image-container">
                                <img src="figures/second_example.png" alt="Scale visualization" className="w-full rounded-lg shadow-sm" />
                            </div>
                        </div>
                    </div>

                    {/* Third progression group */}
                    <div>
                        <div className="bg-white p-3 rounded-lg shadow-sm mb-4">
                            <p className="text-sm">{progressionNotes[2]}</p>
                        </div>
                        <div className="flex flex-col md:flex-row chord-progressions gap-4">
                            <div className="flex-1">
                                <div className="grid gap-1">
                                    {progressions.slice(groupStartIndices[2]).map((row, rowIndex) => {
                                        const adjustedRowIndex = rowIndex + groupStartIndices[2];
                                        return (
                                            <div key={adjustedRowIndex} className="flex gap-1 items-center">
                                                {row.chords.map((chord, colIndex) => (
                                                    <button
                                                        key={`${adjustedRowIndex}-${colIndex}`}
                                                        onClick={() => handleChordClick(chord, adjustedRowIndex, colIndex)}
                                                        className={`text-xs p-3 rounded-xl flex-1 text-center transition-colors border border-gray-300 chord-button
                                                ${chord === ''
                                                                ? 'border-none'
                                                                : activeButtons.has(`${adjustedRowIndex}-${colIndex}`)
                                                                    ? 'text-white'
                                                                    : loadingStatus.get(chord) === false
                                                                        ? 'bg-red-100 text-red-600'
                                                                        : 'bg-white hover:bg-gray-200'
                                                            }`}
                                                        style={{
                                                            backgroundColor: activeButtons.has(`${adjustedRowIndex}-${colIndex}`) ? 'var(--button-active)' : ''
                                                        }}
                                                        disabled={chord === '' || loadingStatus.get(chord) !== true}
                                                    >
                                                        {chord}
                                                    </button>
                                                ))}
                                                <div className="w-24 text-gray-600 font-medium text-xs">
                                                    {row.label}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                            <div className="image-container">
                                <img src="figures/third_example.png" alt="Scale visualization" className="w-full rounded-lg shadow-sm" />
                            </div>
                        </div>
                    </div>

                    <div className="mt-4 text-sm text-gray-500">
                        Note: Click on any chord to hear it.
                    </div>
                    {debugInfo && (
                        <div className="mt-2 p-2 bg-red-50 text-red-600 rounded text-sm">
                            {debugInfo}
                        </div>
                    )}
                </div>
            );
        };

        // Mount the React component
        const root = ReactDOM.createRoot(document.getElementById('chord-progression-root'));
            root.render(
                <React.Fragment>
                    <ModalInterchangeInfo />
                    <ChordProgressionGrid />
                </React.Fragment>
            );

        // Add placeholder image handling
            window.addEventListener('DOMContentLoaded', () => {
                // This function will attempt to preload images
                // and provide a fallback if they don't exist
                const checkImageExists = (url) => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => resolve(true);
                        img.onerror = () => resolve(false);
                        img.src = url;
                    });
                };

                // Check all progression image URLs
                const imageUrls = [
                    'figures/first_example.png',
                    'figures/second_example.png',
                    'figures/third_example.png'
                ];

                imageUrls.forEach(async (url) => {
                    const exists = await checkImageExists(url);
                    if (!exists) {
                        console.warn(`Image not found: ${url}`);
                        // Images that don't load will display with alt text
                    }
                });
            });
    </script>

</body>
</html>